Задача 1.

Като се използва следната реализация на шаблонния клас LinkedList: https://github.com/nkvelkov/OOP2018/blob/master/exercise8/LinkedList.cpp,

да се напишат шаблонни класове Stack и Queue, представящи съответно структурите стек и опашка.

Класовете Stack и Queue трябва да наследяват LinkedList и да преизползват неговата функционалност, като особеностите са:

- при стека може да се добавят и премахват елементи само в началото на списъка;

- при опашката може да се добавят елементи само в началото на списъка, а да се премахват – само от края (по принцип при класическата опашка е обратното, но тук ще си позволим да обърнем нещата, за да преизползваме наличната функционалност на LinkedList).

Стекът и опашката трябва да имат функционалност, показваща дали съответната структура е празна, както и такава, даваща информация за броя елементи в структурата. Трябва да може и да се връща елементът на върха, т.е. този, който би бил изваден при операция изваждане. Не трябва обектите на стека и опашката да имат достъп до излишната функционалност на свързания списък. Помислете за необходимите методи, техните атрибути за достъп, както и начинът на наследяване (public, private или protected).

Задача 2.

Да се реализира клас служител, Employee. Всеки служител има:

-  име - символен низ с произволна дължина.

-  стаж - цяло неотрицателно число.

-  getSalary - връща стаж * 2 + 500.

Да се реализира клас продавач, Sales, който е служител. Всеки продавач има:

-  брой направени продажби - цяло неотрицателно число.

-  getSalary - връща брой продажби * 3 + 100.

Да се реализира клас Programmer, който е Employee. Всеки програмист има:

-  брой написани програми - цяло неотрицателно число.

-  getSalary - връща броя на програмите + 200.

Да се дефинира клас Manager, който е едновременно програмист и търговец. Нека класът има:

-  прякор - символен низ с произволна дължина.

-  брой на спечелени акции.

-  getSalary - метод, връщащ броя акции * 3 + 1000.

Реализирайте за всеки клас:

-  get и set методи за всички характеристики.

-  канонично представяне, където е необходимо

-  конструктор с параметри за всички член-данни

Също така, към всеки клас да се добави следната член-функция:

Employee* clone() const { return new Derived(*this);}

където вместо Derived е името на съответния клас. Тази функция да се използва при откопирването на масиви от указатели от тип Employee, реализиращи полиморфизъм.

Задача 3

Да се дефинира клас Company със следните член-данни и методи:

-  масив от служители (това включва служители, продавачи, програмисти и мениджъри) с произволна дължина;

-  брой на елементите в този масив;

-  addEmployee(const Employee&) - добавя работник в масива;

-  removeSales(int) - премахва продавачите, чиято заплата е по-голяма от числото, подадено като аргумент;

-  removeProgrammer(int) - премахва програмистите, чиято заплата е по-голяма от числото, подадено като аргумент;

-  removeManager(int) - премахва шефовете, чиято заплата е по-голяма от числото, подадено като аргумент;

-  removeEmployee(int) - премахва служителите, чиято заплата е по-голяма от числото, подадено като аргумент.
